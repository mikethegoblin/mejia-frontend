{"version":3,"file":"425c4608fb358c9d99fdfdfe47aa9f63a6f3f6f6-b9ecf07fe60593e1871f.js","mappings":"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","sources":["webpack://mutual-aid-site/./node_modules/@babel/runtime/helpers/interopRequireWildcard.js","webpack://mutual-aid-site/./node_modules/@material-ui/core/esm/utils/deprecatedPropType.js","webpack://mutual-aid-site/./node_modules/@material-ui/core/esm/utils/requirePropFactory.js","webpack://mutual-aid-site/./node_modules/@material-ui/core/esm/utils/unsupportedProp.js","webpack://mutual-aid-site/./node_modules/@material-ui/core/esm/utils/unstable_useId.js","webpack://mutual-aid-site/./node_modules/@material-ui/icons/ExpandLess.js","webpack://mutual-aid-site/./node_modules/@material-ui/icons/ExpandMore.js","webpack://mutual-aid-site/./node_modules/@material-ui/icons/utils/createSvgIcon.js","webpack://mutual-aid-site/./node_modules/@turf/helpers/dist/es/index.js","webpack://mutual-aid-site/./node_modules/@turf/meta/dist/es/index.js","webpack://mutual-aid-site/./node_modules/@turf/centroid/dist/es/index.js","webpack://mutual-aid-site/./node_modules/@material-ui/core/esm/Card/Card.js","webpack://mutual-aid-site/./node_modules/@material-ui/core/esm/CardContent/CardContent.js","webpack://mutual-aid-site/./node_modules/@material-ui/core/esm/Typography/Typography.js","webpack://mutual-aid-site/./node_modules/@material-ui/core/esm/ListItemText/ListItemText.js","webpack://mutual-aid-site/./node_modules/@material-ui/core/esm/Collapse/Collapse.js","webpack://mutual-aid-site/./src/images/julia1.jpg","webpack://mutual-aid-site/./src/pages/components/Map.js"],"sourcesContent":["var _typeof = require(\"@babel/runtime/helpers/typeof\")[\"default\"];\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n    return {\n      \"default\": obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache(nodeInterop);\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj[\"default\"] = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nmodule.exports = _interopRequireWildcard;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;","export default function deprecatedPropType(validator, reason) {\n  if (process.env.NODE_ENV === 'production') {\n    return function () {\n      return null;\n    };\n  }\n\n  return function (props, propName, componentName, location, propFullName) {\n    var componentNameSafe = componentName || '<<anonymous>>';\n    var propFullNameSafe = propFullName || propName;\n\n    if (typeof props[propName] !== 'undefined') {\n      return new Error(\"The \".concat(location, \" `\").concat(propFullNameSafe, \"` of \") + \"`\".concat(componentNameSafe, \"` is deprecated. \").concat(reason));\n    }\n\n    return null;\n  };\n}","export default function requirePropFactory(componentNameInError) {\n  if (process.env.NODE_ENV === 'production') {\n    return function () {\n      return null;\n    };\n  }\n\n  var requireProp = function requireProp(requiredProp) {\n    return function (props, propName, componentName, location, propFullName) {\n      var propFullNameSafe = propFullName || propName;\n\n      if (typeof props[propName] !== 'undefined' && !props[requiredProp]) {\n        return new Error(\"The prop `\".concat(propFullNameSafe, \"` of \") + \"`\".concat(componentNameInError, \"` must be used on `\").concat(requiredProp, \"`.\"));\n      }\n\n      return null;\n    };\n  };\n\n  return requireProp;\n}","export default function unsupportedProp(props, propName, componentName, location, propFullName) {\n  if (process.env.NODE_ENV === 'production') {\n    return null;\n  }\n\n  var propFullNameSafe = propFullName || propName;\n\n  if (typeof props[propName] !== 'undefined') {\n    return new Error(\"The prop `\".concat(propFullNameSafe, \"` is not supported. Please remove it.\"));\n  }\n\n  return null;\n}","import * as React from 'react';\n/**\n * Private module reserved for @material-ui/x packages.\n */\n\nexport default function useId(idOverride) {\n  var _React$useState = React.useState(idOverride),\n      defaultId = _React$useState[0],\n      setDefaultId = _React$useState[1];\n\n  var id = idOverride || defaultId;\n  React.useEffect(function () {\n    if (defaultId == null) {\n      // Fallback to this default id when possible.\n      // Use the random value for client-side rendering only.\n      // We can't use it server-side.\n      setDefaultId(\"mui-\".concat(Math.round(Math.random() * 1e5)));\n    }\n  }, [defaultId]);\n  return id;\n}","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar React = _interopRequireWildcard(require(\"react\"));\n\nvar _createSvgIcon = _interopRequireDefault(require(\"./utils/createSvgIcon\"));\n\nvar _default = (0, _createSvgIcon.default)( /*#__PURE__*/React.createElement(\"path\", {\n  d: \"M12 8l-6 6 1.41 1.41L12 10.83l4.59 4.58L18 14z\"\n}), 'ExpandLess');\n\nexports.default = _default;","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar React = _interopRequireWildcard(require(\"react\"));\n\nvar _createSvgIcon = _interopRequireDefault(require(\"./utils/createSvgIcon\"));\n\nvar _default = (0, _createSvgIcon.default)( /*#__PURE__*/React.createElement(\"path\", {\n  d: \"M16.59 8.59L12 13.17 7.41 8.59 6 10l6 6 6-6z\"\n}), 'ExpandMore');\n\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"default\", {\n  enumerable: true,\n  get: function get() {\n    return _utils.createSvgIcon;\n  }\n});\n\nvar _utils = require(\"@material-ui/core/utils\");","/**\n * @module helpers\n */\n\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nexport var earthRadius = 6371008.8;\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * @memberof helpers\n * @type {Object}\n */\n\nexport var factors = {\n  centimeters: earthRadius * 100,\n  centimetres: earthRadius * 100,\n  degrees: earthRadius / 111325,\n  feet: earthRadius * 3.28084,\n  inches: earthRadius * 39.37,\n  kilometers: earthRadius / 1000,\n  kilometres: earthRadius / 1000,\n  meters: earthRadius,\n  metres: earthRadius,\n  miles: earthRadius / 1609.344,\n  millimeters: earthRadius * 1000,\n  millimetres: earthRadius * 1000,\n  nauticalmiles: earthRadius / 1852,\n  radians: 1,\n  yards: earthRadius * 1.0936\n};\n/**\n * Units of measurement factors based on 1 meter.\n *\n * @memberof helpers\n * @type {Object}\n */\n\nexport var unitsFactors = {\n  centimeters: 100,\n  centimetres: 100,\n  degrees: 1 / 111325,\n  feet: 3.28084,\n  inches: 39.37,\n  kilometers: 1 / 1000,\n  kilometres: 1 / 1000,\n  meters: 1,\n  metres: 1,\n  miles: 1 / 1609.344,\n  millimeters: 1000,\n  millimetres: 1000,\n  nauticalmiles: 1 / 1852,\n  radians: 1 / earthRadius,\n  yards: 1.0936133\n};\n/**\n * Area of measurement factors based on 1 square meter.\n *\n * @memberof helpers\n * @type {Object}\n */\n\nexport var areaFactors = {\n  acres: 0.000247105,\n  centimeters: 10000,\n  centimetres: 10000,\n  feet: 10.763910417,\n  hectares: 0.0001,\n  inches: 1550.003100006,\n  kilometers: 0.000001,\n  kilometres: 0.000001,\n  meters: 1,\n  metres: 1,\n  miles: 3.86e-7,\n  millimeters: 1000000,\n  millimetres: 1000000,\n  yards: 1.195990046\n};\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\n\nexport function feature(geom, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var feat = {\n    type: \"Feature\"\n  };\n\n  if (options.id === 0 || options.id) {\n    feat.id = options.id;\n  }\n\n  if (options.bbox) {\n    feat.bbox = options.bbox;\n  }\n\n  feat.properties = properties || {};\n  feat.geometry = geom;\n  return feat;\n}\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\n\nexport function geometry(type, coordinates, _options) {\n  if (_options === void 0) {\n    _options = {};\n  }\n\n  switch (type) {\n    case \"Point\":\n      return point(coordinates).geometry;\n\n    case \"LineString\":\n      return lineString(coordinates).geometry;\n\n    case \"Polygon\":\n      return polygon(coordinates).geometry;\n\n    case \"MultiPoint\":\n      return multiPoint(coordinates).geometry;\n\n    case \"MultiLineString\":\n      return multiLineString(coordinates).geometry;\n\n    case \"MultiPolygon\":\n      return multiPolygon(coordinates).geometry;\n\n    default:\n      throw new Error(type + \" is invalid\");\n  }\n}\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\n\nexport function point(coordinates, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  if (!coordinates) {\n    throw new Error(\"coordinates is required\");\n  }\n\n  if (!Array.isArray(coordinates)) {\n    throw new Error(\"coordinates must be an Array\");\n  }\n\n  if (coordinates.length < 2) {\n    throw new Error(\"coordinates must be at least 2 numbers long\");\n  }\n\n  if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {\n    throw new Error(\"coordinates must contain numbers\");\n  }\n\n  var geom = {\n    type: \"Point\",\n    coordinates: coordinates\n  };\n  return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\n\nexport function points(coordinates, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return featureCollection(coordinates.map(function (coords) {\n    return point(coords, properties);\n  }), options);\n}\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\n\nexport function polygon(coordinates, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\n    var ring = coordinates_1[_i];\n\n    if (ring.length < 4) {\n      throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n    }\n\n    for (var j = 0; j < ring[ring.length - 1].length; j++) {\n      // Check if first point of Polygon contains two numbers\n      if (ring[ring.length - 1][j] !== ring[0][j]) {\n        throw new Error(\"First and last Position are not equivalent.\");\n      }\n    }\n  }\n\n  var geom = {\n    type: \"Polygon\",\n    coordinates: coordinates\n  };\n  return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\n\nexport function polygons(coordinates, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return featureCollection(coordinates.map(function (coords) {\n    return polygon(coords, properties);\n  }), options);\n}\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\n\nexport function lineString(coordinates, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  if (coordinates.length < 2) {\n    throw new Error(\"coordinates must be an array of two or more positions\");\n  }\n\n  var geom = {\n    type: \"LineString\",\n    coordinates: coordinates\n  };\n  return feature(geom, properties, options);\n}\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\n\nexport function lineStrings(coordinates, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return featureCollection(coordinates.map(function (coords) {\n    return lineString(coords, properties);\n  }), options);\n}\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\n\nexport function featureCollection(features, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var fc = {\n    type: \"FeatureCollection\"\n  };\n\n  if (options.id) {\n    fc.id = options.id;\n  }\n\n  if (options.bbox) {\n    fc.bbox = options.bbox;\n  }\n\n  fc.features = features;\n  return fc;\n}\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\n\nexport function multiLineString(coordinates, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var geom = {\n    type: \"MultiLineString\",\n    coordinates: coordinates\n  };\n  return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\n\nexport function multiPoint(coordinates, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var geom = {\n    type: \"MultiPoint\",\n    coordinates: coordinates\n  };\n  return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\n\nexport function multiPolygon(coordinates, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var geom = {\n    type: \"MultiPolygon\",\n    coordinates: coordinates\n  };\n  return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\n\nexport function geometryCollection(geometries, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var geom = {\n    type: \"GeometryCollection\",\n    geometries: geometries\n  };\n  return feature(geom, properties, options);\n}\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\n\nexport function round(num, precision) {\n  if (precision === void 0) {\n    precision = 0;\n  }\n\n  if (precision && !(precision >= 0)) {\n    throw new Error(\"precision must be a positive number\");\n  }\n\n  var multiplier = Math.pow(10, precision || 0);\n  return Math.round(num * multiplier) / multiplier;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\n\nexport function radiansToLength(radians, units) {\n  if (units === void 0) {\n    units = \"kilometers\";\n  }\n\n  var factor = factors[units];\n\n  if (!factor) {\n    throw new Error(units + \" units is invalid\");\n  }\n\n  return radians * factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\n\nexport function lengthToRadians(distance, units) {\n  if (units === void 0) {\n    units = \"kilometers\";\n  }\n\n  var factor = factors[units];\n\n  if (!factor) {\n    throw new Error(units + \" units is invalid\");\n  }\n\n  return distance / factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\n\nexport function lengthToDegrees(distance, units) {\n  return radiansToDegrees(lengthToRadians(distance, units));\n}\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\n\nexport function bearingToAzimuth(bearing) {\n  var angle = bearing % 360;\n\n  if (angle < 0) {\n    angle += 360;\n  }\n\n  return angle;\n}\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\n\nexport function radiansToDegrees(radians) {\n  var degrees = radians % (2 * Math.PI);\n  return degrees * 180 / Math.PI;\n}\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\n\nexport function degreesToRadians(degrees) {\n  var radians = degrees % 360;\n  return radians * Math.PI / 180;\n}\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] of the length\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted length\n */\n\nexport function convertLength(length, originalUnit, finalUnit) {\n  if (originalUnit === void 0) {\n    originalUnit = \"kilometers\";\n  }\n\n  if (finalUnit === void 0) {\n    finalUnit = \"kilometers\";\n  }\n\n  if (!(length >= 0)) {\n    throw new Error(\"length must be a positive number\");\n  }\n\n  return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches, hectares\n * @param {number} area to be converted\n * @param {Units} [originalUnit=\"meters\"] of the distance\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted area\n */\n\nexport function convertArea(area, originalUnit, finalUnit) {\n  if (originalUnit === void 0) {\n    originalUnit = \"meters\";\n  }\n\n  if (finalUnit === void 0) {\n    finalUnit = \"kilometers\";\n  }\n\n  if (!(area >= 0)) {\n    throw new Error(\"area must be a positive number\");\n  }\n\n  var startFactor = areaFactors[originalUnit];\n\n  if (!startFactor) {\n    throw new Error(\"invalid original units\");\n  }\n\n  var finalFactor = areaFactors[finalUnit];\n\n  if (!finalFactor) {\n    throw new Error(\"invalid final units\");\n  }\n\n  return area / startFactor * finalFactor;\n}\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\n\nexport function isNumber(num) {\n  return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\n\nexport function isObject(input) {\n  return !!input && input.constructor === Object;\n}\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\n\nexport function validateBBox(bbox) {\n  if (!bbox) {\n    throw new Error(\"bbox is required\");\n  }\n\n  if (!Array.isArray(bbox)) {\n    throw new Error(\"bbox must be an Array\");\n  }\n\n  if (bbox.length !== 4 && bbox.length !== 6) {\n    throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n  }\n\n  bbox.forEach(function (num) {\n    if (!isNumber(num)) {\n      throw new Error(\"bbox must only contain numbers\");\n    }\n  });\n}\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\n\nexport function validateId(id) {\n  if (!id) {\n    throw new Error(\"id is required\");\n  }\n\n  if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n    throw new Error(\"id must be a number or a string\");\n  }\n}","import { feature, lineString, isObject, point } from '@turf/helpers';\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\n\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n  // Handles null Geometry -- Skips this GeoJSON\n  if (geojson === null) return;\n  var j,\n      k,\n      l,\n      geometry,\n      stopG,\n      coords,\n      geometryMaybeCollection,\n      wrapShrink = 0,\n      coordIndex = 0,\n      isGeometryCollection,\n      type = geojson.type,\n      isFeatureCollection = type === \"FeatureCollection\",\n      isFeature = type === \"Feature\",\n      stop = isFeatureCollection ? geojson.features.length : 1; // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n\n  for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n    geometryMaybeCollection = isFeatureCollection ? geojson.features[featureIndex].geometry : isFeature ? geojson.geometry : geojson;\n    isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === \"GeometryCollection\" : false;\n    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n    for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n      var multiFeatureIndex = 0;\n      var geometryIndex = 0;\n      geometry = isGeometryCollection ? geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection; // Handles null Geometry -- Skips this geometry\n\n      if (geometry === null) continue;\n      coords = geometry.coordinates;\n      var geomType = geometry.type;\n      wrapShrink = excludeWrapCoord && (geomType === \"Polygon\" || geomType === \"MultiPolygon\") ? 1 : 0;\n\n      switch (geomType) {\n        case null:\n          break;\n\n        case \"Point\":\n          if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n          coordIndex++;\n          multiFeatureIndex++;\n          break;\n\n        case \"LineString\":\n        case \"MultiPoint\":\n          for (j = 0; j < coords.length; j++) {\n            if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n            coordIndex++;\n            if (geomType === \"MultiPoint\") multiFeatureIndex++;\n          }\n\n          if (geomType === \"LineString\") multiFeatureIndex++;\n          break;\n\n        case \"Polygon\":\n        case \"MultiLineString\":\n          for (j = 0; j < coords.length; j++) {\n            for (k = 0; k < coords[j].length - wrapShrink; k++) {\n              if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n              coordIndex++;\n            }\n\n            if (geomType === \"MultiLineString\") multiFeatureIndex++;\n            if (geomType === \"Polygon\") geometryIndex++;\n          }\n\n          if (geomType === \"Polygon\") multiFeatureIndex++;\n          break;\n\n        case \"MultiPolygon\":\n          for (j = 0; j < coords.length; j++) {\n            geometryIndex = 0;\n\n            for (k = 0; k < coords[j].length; k++) {\n              for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                coordIndex++;\n              }\n\n              geometryIndex++;\n            }\n\n            multiFeatureIndex++;\n          }\n\n          break;\n\n        case \"GeometryCollection\":\n          for (j = 0; j < geometry.geometries.length; j++) {\n            if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false;\n          }\n\n          break;\n\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n  }\n}\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\n\n\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n  var previousValue = initialValue;\n  coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n    if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n  }, excludeWrapCoord);\n  return previousValue;\n}\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\n\n\nfunction propEach(geojson, callback) {\n  var i;\n\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      for (i = 0; i < geojson.features.length; i++) {\n        if (callback(geojson.features[i].properties, i) === false) break;\n      }\n\n      break;\n\n    case \"Feature\":\n      callback(geojson.properties, 0);\n      break;\n  }\n}\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\n\n\nfunction propReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  propEach(geojson, function (currentProperties, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;else previousValue = callback(previousValue, currentProperties, featureIndex);\n  });\n  return previousValue;\n}\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\n\n\nfunction featureEach(geojson, callback) {\n  if (geojson.type === \"Feature\") {\n    callback(geojson, 0);\n  } else if (geojson.type === \"FeatureCollection\") {\n    for (var i = 0; i < geojson.features.length; i++) {\n      if (callback(geojson.features[i], i) === false) break;\n    }\n  }\n}\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\n\n\nfunction featureReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  featureEach(geojson, function (currentFeature, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;else previousValue = callback(previousValue, currentFeature, featureIndex);\n  });\n  return previousValue;\n}\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\n\n\nfunction coordAll(geojson) {\n  var coords = [];\n  coordEach(geojson, function (coord) {\n    coords.push(coord);\n  });\n  return coords;\n}\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\n\n\nfunction geomEach(geojson, callback) {\n  var i,\n      j,\n      g,\n      geometry,\n      stopG,\n      geometryMaybeCollection,\n      isGeometryCollection,\n      featureProperties,\n      featureBBox,\n      featureId,\n      featureIndex = 0,\n      isFeatureCollection = geojson.type === \"FeatureCollection\",\n      isFeature = geojson.type === \"Feature\",\n      stop = isFeatureCollection ? geojson.features.length : 1; // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n\n  for (i = 0; i < stop; i++) {\n    geometryMaybeCollection = isFeatureCollection ? geojson.features[i].geometry : isFeature ? geojson.geometry : geojson;\n    featureProperties = isFeatureCollection ? geojson.features[i].properties : isFeature ? geojson.properties : {};\n    featureBBox = isFeatureCollection ? geojson.features[i].bbox : isFeature ? geojson.bbox : undefined;\n    featureId = isFeatureCollection ? geojson.features[i].id : isFeature ? geojson.id : undefined;\n    isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === \"GeometryCollection\" : false;\n    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n    for (g = 0; g < stopG; g++) {\n      geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection; // Handle null Geometry\n\n      if (geometry === null) {\n        if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n        continue;\n      }\n\n      switch (geometry.type) {\n        case \"Point\":\n        case \"LineString\":\n        case \"MultiPoint\":\n        case \"Polygon\":\n        case \"MultiLineString\":\n        case \"MultiPolygon\":\n          {\n            if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n            break;\n          }\n\n        case \"GeometryCollection\":\n          {\n            for (j = 0; j < geometry.geometries.length; j++) {\n              if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n            }\n\n            break;\n          }\n\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    } // Only increase `featureIndex` per each feature\n\n\n    featureIndex++;\n  }\n}\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\n\n\nfunction geomReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n    if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);\n  });\n  return previousValue;\n}\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\n\n\nfunction flattenEach(geojson, callback) {\n  geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n    // Callback for single geometry\n    var type = geometry === null ? null : geometry.type;\n\n    switch (type) {\n      case null:\n      case \"Point\":\n      case \"LineString\":\n      case \"Polygon\":\n        if (callback(feature(geometry, properties, {\n          bbox: bbox,\n          id: id\n        }), featureIndex, 0) === false) return false;\n        return;\n    }\n\n    var geomType; // Callback for multi-geometry\n\n    switch (type) {\n      case \"MultiPoint\":\n        geomType = \"Point\";\n        break;\n\n      case \"MultiLineString\":\n        geomType = \"LineString\";\n        break;\n\n      case \"MultiPolygon\":\n        geomType = \"Polygon\";\n        break;\n    }\n\n    for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n      var coordinate = geometry.coordinates[multiFeatureIndex];\n      var geom = {\n        type: geomType,\n        coordinates: coordinate\n      };\n      if (callback(feature(geom, properties), featureIndex, multiFeatureIndex) === false) return false;\n    }\n  });\n}\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\n\n\nfunction flattenReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {\n    if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);\n  });\n  return previousValue;\n}\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\n\n\nfunction segmentEach(geojson, callback) {\n  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n    var segmentIndex = 0; // Exclude null Geometries\n\n    if (!feature.geometry) return; // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n\n    var type = feature.geometry.type;\n    if (type === \"Point\" || type === \"MultiPoint\") return; // Generate 2-vertex line segments\n\n    var previousCoords;\n    var previousFeatureIndex = 0;\n    var previousMultiIndex = 0;\n    var prevGeomIndex = 0;\n    if (coordEach(feature, function (currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {\n      // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n      if (previousCoords === undefined || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {\n        previousCoords = currentCoord;\n        previousFeatureIndex = featureIndex;\n        previousMultiIndex = multiPartIndexCoord;\n        prevGeomIndex = geometryIndex;\n        segmentIndex = 0;\n        return;\n      }\n\n      var currentSegment = lineString([previousCoords, currentCoord], feature.properties);\n      if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false) return false;\n      segmentIndex++;\n      previousCoords = currentCoord;\n    }) === false) return false;\n  });\n}\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentIndex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\n\n\nfunction segmentReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  var started = false;\n  segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n    if (started === false && initialValue === undefined) previousValue = currentSegment;else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);\n    started = true;\n  });\n  return previousValue;\n}\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\n\n\nfunction lineEach(geojson, callback) {\n  // validation\n  if (!geojson) throw new Error(\"geojson is required\");\n  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n    if (feature.geometry === null) return;\n    var type = feature.geometry.type;\n    var coords = feature.geometry.coordinates;\n\n    switch (type) {\n      case \"LineString\":\n        if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false) return false;\n        break;\n\n      case \"Polygon\":\n        for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n          if (callback(lineString(coords[geometryIndex], feature.properties), featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n        }\n\n        break;\n    }\n  });\n}\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\n\n\nfunction lineReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n    if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);\n  });\n  return previousValue;\n}\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\n\n\nfunction findSegment(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var segmentIndex = options.segmentIndex || 0; // Find FeatureIndex\n\n  var properties = options.properties;\n  var geometry;\n\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n\n    default:\n      throw new Error(\"geojson is invalid\");\n  } // Find SegmentIndex\n\n\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n\n  switch (geometry.type) {\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n\n    case \"LineString\":\n      if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n      return lineString([coords[segmentIndex], coords[segmentIndex + 1]], properties, options);\n\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (segmentIndex < 0) segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n      return lineString([coords[geometryIndex][segmentIndex], coords[geometryIndex][segmentIndex + 1]], properties, options);\n\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n      return lineString([coords[multiFeatureIndex][segmentIndex], coords[multiFeatureIndex][segmentIndex + 1]], properties, options);\n\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n      return lineString([coords[multiFeatureIndex][geometryIndex][segmentIndex], coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]], properties, options);\n  }\n\n  throw new Error(\"geojson is invalid\");\n}\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\n\n\nfunction findPoint(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var coordIndex = options.coordIndex || 0; // Find FeatureIndex\n\n  var properties = options.properties;\n  var geometry;\n\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n\n    default:\n      throw new Error(\"geojson is invalid\");\n  } // Find Coord Index\n\n\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n\n  switch (geometry.type) {\n    case \"Point\":\n      return point(coords, properties, options);\n\n    case \"MultiPoint\":\n      if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n      return point(coords[multiFeatureIndex], properties, options);\n\n    case \"LineString\":\n      if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n      return point(coords[coordIndex], properties, options);\n\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (coordIndex < 0) coordIndex = coords[geometryIndex].length + coordIndex;\n      return point(coords[geometryIndex][coordIndex], properties, options);\n\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (coordIndex < 0) coordIndex = coords[multiFeatureIndex].length + coordIndex;\n      return point(coords[multiFeatureIndex][coordIndex], properties, options);\n\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (coordIndex < 0) coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n      return point(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);\n  }\n\n  throw new Error(\"geojson is invalid\");\n}\n\nexport { coordAll, coordEach, coordReduce, featureEach, featureReduce, findPoint, findSegment, flattenEach, flattenReduce, geomEach, geomReduce, lineEach, lineReduce, propEach, propReduce, segmentEach, segmentReduce };","import { coordEach } from \"@turf/meta\";\nimport { point } from \"@turf/helpers\";\n/**\n * Takes one or more features and calculates the centroid using the mean of all vertices.\n * This lessens the effect of small islands and artifacts when calculating the centroid of a set of polygons.\n *\n * @name centroid\n * @param {GeoJSON} geojson GeoJSON to be centered\n * @param {Object} [options={}] Optional Parameters\n * @param {Object} [options.properties={}] an Object that is used as the {@link Feature}'s properties\n * @returns {Feature<Point>} the centroid of the input features\n * @example\n * var polygon = turf.polygon([[[-81, 41], [-88, 36], [-84, 31], [-80, 33], [-77, 39], [-81, 41]]]);\n *\n * var centroid = turf.centroid(polygon);\n *\n * //addToMap\n * var addToMap = [polygon, centroid]\n */\n\nfunction centroid(geojson, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var xSum = 0;\n  var ySum = 0;\n  var len = 0;\n  coordEach(geojson, function (coord) {\n    xSum += coord[0];\n    ySum += coord[1];\n    len++;\n  }, true);\n  return point([xSum / len, ySum / len], options.properties);\n}\n\nexport default centroid;","import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport * as React from 'react';\nimport clsx from 'clsx';\nimport Paper from '../Paper';\nimport withStyles from '../styles/withStyles';\nexport var styles = {\n  /* Styles applied to the root element. */\n  root: {\n    overflow: 'hidden'\n  }\n};\nvar Card = /*#__PURE__*/React.forwardRef(function Card(props, ref) {\n  var classes = props.classes,\n      className = props.className,\n      _props$raised = props.raised,\n      raised = _props$raised === void 0 ? false : _props$raised,\n      other = _objectWithoutProperties(props, [\"classes\", \"className\", \"raised\"]);\n\n  return /*#__PURE__*/React.createElement(Paper, _extends({\n    className: clsx(classes.root, className),\n    elevation: raised ? 8 : 1,\n    ref: ref\n  }, other));\n});\nprocess.env.NODE_ENV !== \"production\" ? void 0 : void 0;\nexport default withStyles(styles, {\n  name: 'MuiCard'\n})(Card);","import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport * as React from 'react';\nimport clsx from 'clsx';\nimport withStyles from '../styles/withStyles';\nexport var styles = {\n  /* Styles applied to the root element. */\n  root: {\n    padding: 16,\n    '&:last-child': {\n      paddingBottom: 24\n    }\n  }\n};\nvar CardContent = /*#__PURE__*/React.forwardRef(function CardContent(props, ref) {\n  var classes = props.classes,\n      className = props.className,\n      _props$component = props.component,\n      Component = _props$component === void 0 ? 'div' : _props$component,\n      other = _objectWithoutProperties(props, [\"classes\", \"className\", \"component\"]);\n\n  return /*#__PURE__*/React.createElement(Component, _extends({\n    className: clsx(classes.root, className),\n    ref: ref\n  }, other));\n});\nprocess.env.NODE_ENV !== \"production\" ? void 0 : void 0;\nexport default withStyles(styles, {\n  name: 'MuiCardContent'\n})(CardContent);","import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport * as React from 'react';\nimport clsx from 'clsx';\nimport withStyles from '../styles/withStyles';\nimport capitalize from '../utils/capitalize';\nexport var styles = function styles(theme) {\n  return {\n    /* Styles applied to the root element. */\n    root: {\n      margin: 0\n    },\n\n    /* Styles applied to the root element if `variant=\"body2\"`. */\n    body2: theme.typography.body2,\n\n    /* Styles applied to the root element if `variant=\"body1\"`. */\n    body1: theme.typography.body1,\n\n    /* Styles applied to the root element if `variant=\"caption\"`. */\n    caption: theme.typography.caption,\n\n    /* Styles applied to the root element if `variant=\"button\"`. */\n    button: theme.typography.button,\n\n    /* Styles applied to the root element if `variant=\"h1\"`. */\n    h1: theme.typography.h1,\n\n    /* Styles applied to the root element if `variant=\"h2\"`. */\n    h2: theme.typography.h2,\n\n    /* Styles applied to the root element if `variant=\"h3\"`. */\n    h3: theme.typography.h3,\n\n    /* Styles applied to the root element if `variant=\"h4\"`. */\n    h4: theme.typography.h4,\n\n    /* Styles applied to the root element if `variant=\"h5\"`. */\n    h5: theme.typography.h5,\n\n    /* Styles applied to the root element if `variant=\"h6\"`. */\n    h6: theme.typography.h6,\n\n    /* Styles applied to the root element if `variant=\"subtitle1\"`. */\n    subtitle1: theme.typography.subtitle1,\n\n    /* Styles applied to the root element if `variant=\"subtitle2\"`. */\n    subtitle2: theme.typography.subtitle2,\n\n    /* Styles applied to the root element if `variant=\"overline\"`. */\n    overline: theme.typography.overline,\n\n    /* Styles applied to the root element if `variant=\"srOnly\"`. Only accessible to screen readers. */\n    srOnly: {\n      position: 'absolute',\n      height: 1,\n      width: 1,\n      overflow: 'hidden'\n    },\n\n    /* Styles applied to the root element if `align=\"left\"`. */\n    alignLeft: {\n      textAlign: 'left'\n    },\n\n    /* Styles applied to the root element if `align=\"center\"`. */\n    alignCenter: {\n      textAlign: 'center'\n    },\n\n    /* Styles applied to the root element if `align=\"right\"`. */\n    alignRight: {\n      textAlign: 'right'\n    },\n\n    /* Styles applied to the root element if `align=\"justify\"`. */\n    alignJustify: {\n      textAlign: 'justify'\n    },\n\n    /* Styles applied to the root element if `nowrap={true}`. */\n    noWrap: {\n      overflow: 'hidden',\n      textOverflow: 'ellipsis',\n      whiteSpace: 'nowrap'\n    },\n\n    /* Styles applied to the root element if `gutterBottom={true}`. */\n    gutterBottom: {\n      marginBottom: '0.35em'\n    },\n\n    /* Styles applied to the root element if `paragraph={true}`. */\n    paragraph: {\n      marginBottom: 16\n    },\n\n    /* Styles applied to the root element if `color=\"inherit\"`. */\n    colorInherit: {\n      color: 'inherit'\n    },\n\n    /* Styles applied to the root element if `color=\"primary\"`. */\n    colorPrimary: {\n      color: theme.palette.primary.main\n    },\n\n    /* Styles applied to the root element if `color=\"secondary\"`. */\n    colorSecondary: {\n      color: theme.palette.secondary.main\n    },\n\n    /* Styles applied to the root element if `color=\"textPrimary\"`. */\n    colorTextPrimary: {\n      color: theme.palette.text.primary\n    },\n\n    /* Styles applied to the root element if `color=\"textSecondary\"`. */\n    colorTextSecondary: {\n      color: theme.palette.text.secondary\n    },\n\n    /* Styles applied to the root element if `color=\"error\"`. */\n    colorError: {\n      color: theme.palette.error.main\n    },\n\n    /* Styles applied to the root element if `display=\"inline\"`. */\n    displayInline: {\n      display: 'inline'\n    },\n\n    /* Styles applied to the root element if `display=\"block\"`. */\n    displayBlock: {\n      display: 'block'\n    }\n  };\n};\nvar defaultVariantMapping = {\n  h1: 'h1',\n  h2: 'h2',\n  h3: 'h3',\n  h4: 'h4',\n  h5: 'h5',\n  h6: 'h6',\n  subtitle1: 'h6',\n  subtitle2: 'h6',\n  body1: 'p',\n  body2: 'p'\n};\nvar Typography = /*#__PURE__*/React.forwardRef(function Typography(props, ref) {\n  var _props$align = props.align,\n      align = _props$align === void 0 ? 'inherit' : _props$align,\n      classes = props.classes,\n      className = props.className,\n      _props$color = props.color,\n      color = _props$color === void 0 ? 'initial' : _props$color,\n      component = props.component,\n      _props$display = props.display,\n      display = _props$display === void 0 ? 'initial' : _props$display,\n      _props$gutterBottom = props.gutterBottom,\n      gutterBottom = _props$gutterBottom === void 0 ? false : _props$gutterBottom,\n      _props$noWrap = props.noWrap,\n      noWrap = _props$noWrap === void 0 ? false : _props$noWrap,\n      _props$paragraph = props.paragraph,\n      paragraph = _props$paragraph === void 0 ? false : _props$paragraph,\n      _props$variant = props.variant,\n      variant = _props$variant === void 0 ? 'body1' : _props$variant,\n      _props$variantMapping = props.variantMapping,\n      variantMapping = _props$variantMapping === void 0 ? defaultVariantMapping : _props$variantMapping,\n      other = _objectWithoutProperties(props, [\"align\", \"classes\", \"className\", \"color\", \"component\", \"display\", \"gutterBottom\", \"noWrap\", \"paragraph\", \"variant\", \"variantMapping\"]);\n\n  var Component = component || (paragraph ? 'p' : variantMapping[variant] || defaultVariantMapping[variant]) || 'span';\n  return /*#__PURE__*/React.createElement(Component, _extends({\n    className: clsx(classes.root, className, variant !== 'inherit' && classes[variant], color !== 'initial' && classes[\"color\".concat(capitalize(color))], noWrap && classes.noWrap, gutterBottom && classes.gutterBottom, paragraph && classes.paragraph, align !== 'inherit' && classes[\"align\".concat(capitalize(align))], display !== 'initial' && classes[\"display\".concat(capitalize(display))]),\n    ref: ref\n  }, other));\n});\nprocess.env.NODE_ENV !== \"production\" ? void 0 : void 0;\nexport default withStyles(styles, {\n  name: 'MuiTypography'\n})(Typography);","import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport * as React from 'react';\nimport clsx from 'clsx';\nimport withStyles from '../styles/withStyles';\nimport Typography from '../Typography';\nimport ListContext from '../List/ListContext';\nexport var styles = {\n  /* Styles applied to the root element. */\n  root: {\n    flex: '1 1 auto',\n    minWidth: 0,\n    marginTop: 4,\n    marginBottom: 4\n  },\n\n  /* Styles applied to the `Typography` components if primary and secondary are set. */\n  multiline: {\n    marginTop: 6,\n    marginBottom: 6\n  },\n\n  /* Styles applied to the `Typography` components if dense. */\n  dense: {},\n\n  /* Styles applied to the root element if `inset={true}`. */\n  inset: {\n    paddingLeft: 56\n  },\n\n  /* Styles applied to the primary `Typography` component. */\n  primary: {},\n\n  /* Styles applied to the secondary `Typography` component. */\n  secondary: {}\n};\nvar ListItemText = /*#__PURE__*/React.forwardRef(function ListItemText(props, ref) {\n  var children = props.children,\n      classes = props.classes,\n      className = props.className,\n      _props$disableTypogra = props.disableTypography,\n      disableTypography = _props$disableTypogra === void 0 ? false : _props$disableTypogra,\n      _props$inset = props.inset,\n      inset = _props$inset === void 0 ? false : _props$inset,\n      primaryProp = props.primary,\n      primaryTypographyProps = props.primaryTypographyProps,\n      secondaryProp = props.secondary,\n      secondaryTypographyProps = props.secondaryTypographyProps,\n      other = _objectWithoutProperties(props, [\"children\", \"classes\", \"className\", \"disableTypography\", \"inset\", \"primary\", \"primaryTypographyProps\", \"secondary\", \"secondaryTypographyProps\"]);\n\n  var _React$useContext = React.useContext(ListContext),\n      dense = _React$useContext.dense;\n\n  var primary = primaryProp != null ? primaryProp : children;\n\n  if (primary != null && primary.type !== Typography && !disableTypography) {\n    primary = /*#__PURE__*/React.createElement(Typography, _extends({\n      variant: dense ? 'body2' : 'body1',\n      className: classes.primary,\n      component: \"span\",\n      display: \"block\"\n    }, primaryTypographyProps), primary);\n  }\n\n  var secondary = secondaryProp;\n\n  if (secondary != null && secondary.type !== Typography && !disableTypography) {\n    secondary = /*#__PURE__*/React.createElement(Typography, _extends({\n      variant: \"body2\",\n      className: classes.secondary,\n      color: \"textSecondary\",\n      display: \"block\"\n    }, secondaryTypographyProps), secondary);\n  }\n\n  return /*#__PURE__*/React.createElement(\"div\", _extends({\n    className: clsx(classes.root, className, dense && classes.dense, inset && classes.inset, primary && secondary && classes.multiline),\n    ref: ref\n  }, other), primary, secondary);\n});\nprocess.env.NODE_ENV !== \"production\" ? void 0 : void 0;\nexport default withStyles(styles, {\n  name: 'MuiListItemText'\n})(ListItemText);","import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport * as React from 'react';\nimport clsx from 'clsx';\nimport { chainPropTypes } from '@material-ui/utils';\nimport { Transition } from 'react-transition-group';\nimport withStyles from '../styles/withStyles';\nimport { duration } from '../styles/transitions';\nimport deprecatedPropType from '../utils/deprecatedPropType';\nimport { getTransitionProps } from '../transitions/utils';\nimport useTheme from '../styles/useTheme';\nimport { useForkRef } from '../utils';\nexport var styles = function styles(theme) {\n  return {\n    /* Styles applied to the root element. */\n    root: {\n      height: 0,\n      overflow: 'hidden',\n      transition: theme.transitions.create('height')\n    },\n\n    /* Styles applied to the root element when the transition has entered. */\n    entered: {\n      height: 'auto',\n      overflow: 'visible'\n    },\n\n    /* Styles applied to the root element when the transition has exited and `collapsedSize` != 0px. */\n    hidden: {\n      visibility: 'hidden'\n    },\n\n    /* Styles applied to the outer wrapper element. */\n    wrapper: {\n      // Hack to get children with a negative margin to not falsify the height computation.\n      display: 'flex'\n    },\n\n    /* Styles applied to the inner wrapper element. */\n    wrapperInner: {\n      width: '100%'\n    }\n  };\n};\n/**\n * The Collapse transition is used by the\n * [Vertical Stepper](/components/steppers/#vertical-stepper) StepContent component.\n * It uses [react-transition-group](https://github.com/reactjs/react-transition-group) internally.\n */\n\nvar Collapse = /*#__PURE__*/React.forwardRef(function Collapse(props, ref) {\n  var children = props.children,\n      classes = props.classes,\n      className = props.className,\n      collapsedHeight = props.collapsedHeight,\n      _props$collapsedSize = props.collapsedSize,\n      collapsedSizeProp = _props$collapsedSize === void 0 ? '0px' : _props$collapsedSize,\n      _props$component = props.component,\n      Component = _props$component === void 0 ? 'div' : _props$component,\n      _props$disableStrictM = props.disableStrictModeCompat,\n      disableStrictModeCompat = _props$disableStrictM === void 0 ? false : _props$disableStrictM,\n      inProp = props.in,\n      onEnter = props.onEnter,\n      onEntered = props.onEntered,\n      onEntering = props.onEntering,\n      onExit = props.onExit,\n      onExited = props.onExited,\n      onExiting = props.onExiting,\n      style = props.style,\n      _props$timeout = props.timeout,\n      timeout = _props$timeout === void 0 ? duration.standard : _props$timeout,\n      _props$TransitionComp = props.TransitionComponent,\n      TransitionComponent = _props$TransitionComp === void 0 ? Transition : _props$TransitionComp,\n      other = _objectWithoutProperties(props, [\"children\", \"classes\", \"className\", \"collapsedHeight\", \"collapsedSize\", \"component\", \"disableStrictModeCompat\", \"in\", \"onEnter\", \"onEntered\", \"onEntering\", \"onExit\", \"onExited\", \"onExiting\", \"style\", \"timeout\", \"TransitionComponent\"]);\n\n  var theme = useTheme();\n  var timer = React.useRef();\n  var wrapperRef = React.useRef(null);\n  var autoTransitionDuration = React.useRef();\n  var collapsedSize = typeof (collapsedHeight || collapsedSizeProp) === 'number' ? \"\".concat(collapsedHeight || collapsedSizeProp, \"px\") : collapsedHeight || collapsedSizeProp;\n  React.useEffect(function () {\n    return function () {\n      clearTimeout(timer.current);\n    };\n  }, []);\n  var enableStrictModeCompat = theme.unstable_strictMode && !disableStrictModeCompat;\n  var nodeRef = React.useRef(null);\n  var handleRef = useForkRef(ref, enableStrictModeCompat ? nodeRef : undefined);\n\n  var normalizedTransitionCallback = function normalizedTransitionCallback(callback) {\n    return function (nodeOrAppearing, maybeAppearing) {\n      if (callback) {\n        var _ref = enableStrictModeCompat ? [nodeRef.current, nodeOrAppearing] : [nodeOrAppearing, maybeAppearing],\n            _ref2 = _slicedToArray(_ref, 2),\n            node = _ref2[0],\n            isAppearing = _ref2[1]; // onEnterXxx and onExitXxx callbacks have a different arguments.length value.\n\n\n        if (isAppearing === undefined) {\n          callback(node);\n        } else {\n          callback(node, isAppearing);\n        }\n      }\n    };\n  };\n\n  var handleEnter = normalizedTransitionCallback(function (node, isAppearing) {\n    node.style.height = collapsedSize;\n\n    if (onEnter) {\n      onEnter(node, isAppearing);\n    }\n  });\n  var handleEntering = normalizedTransitionCallback(function (node, isAppearing) {\n    var wrapperHeight = wrapperRef.current ? wrapperRef.current.clientHeight : 0;\n\n    var _getTransitionProps = getTransitionProps({\n      style: style,\n      timeout: timeout\n    }, {\n      mode: 'enter'\n    }),\n        transitionDuration = _getTransitionProps.duration;\n\n    if (timeout === 'auto') {\n      var duration2 = theme.transitions.getAutoHeightDuration(wrapperHeight);\n      node.style.transitionDuration = \"\".concat(duration2, \"ms\");\n      autoTransitionDuration.current = duration2;\n    } else {\n      node.style.transitionDuration = typeof transitionDuration === 'string' ? transitionDuration : \"\".concat(transitionDuration, \"ms\");\n    }\n\n    node.style.height = \"\".concat(wrapperHeight, \"px\");\n\n    if (onEntering) {\n      onEntering(node, isAppearing);\n    }\n  });\n  var handleEntered = normalizedTransitionCallback(function (node, isAppearing) {\n    node.style.height = 'auto';\n\n    if (onEntered) {\n      onEntered(node, isAppearing);\n    }\n  });\n  var handleExit = normalizedTransitionCallback(function (node) {\n    var wrapperHeight = wrapperRef.current ? wrapperRef.current.clientHeight : 0;\n    node.style.height = \"\".concat(wrapperHeight, \"px\");\n\n    if (onExit) {\n      onExit(node);\n    }\n  });\n  var handleExited = normalizedTransitionCallback(onExited);\n  var handleExiting = normalizedTransitionCallback(function (node) {\n    var wrapperHeight = wrapperRef.current ? wrapperRef.current.clientHeight : 0;\n\n    var _getTransitionProps2 = getTransitionProps({\n      style: style,\n      timeout: timeout\n    }, {\n      mode: 'exit'\n    }),\n        transitionDuration = _getTransitionProps2.duration;\n\n    if (timeout === 'auto') {\n      var duration2 = theme.transitions.getAutoHeightDuration(wrapperHeight);\n      node.style.transitionDuration = \"\".concat(duration2, \"ms\");\n      autoTransitionDuration.current = duration2;\n    } else {\n      node.style.transitionDuration = typeof transitionDuration === 'string' ? transitionDuration : \"\".concat(transitionDuration, \"ms\");\n    }\n\n    node.style.height = collapsedSize;\n\n    if (onExiting) {\n      onExiting(node);\n    }\n  });\n\n  var addEndListener = function addEndListener(nodeOrNext, maybeNext) {\n    var next = enableStrictModeCompat ? nodeOrNext : maybeNext;\n\n    if (timeout === 'auto') {\n      timer.current = setTimeout(next, autoTransitionDuration.current || 0);\n    }\n  };\n\n  return /*#__PURE__*/React.createElement(TransitionComponent, _extends({\n    in: inProp,\n    onEnter: handleEnter,\n    onEntered: handleEntered,\n    onEntering: handleEntering,\n    onExit: handleExit,\n    onExited: handleExited,\n    onExiting: handleExiting,\n    addEndListener: addEndListener,\n    nodeRef: enableStrictModeCompat ? nodeRef : undefined,\n    timeout: timeout === 'auto' ? null : timeout\n  }, other), function (state, childProps) {\n    return /*#__PURE__*/React.createElement(Component, _extends({\n      className: clsx(classes.root, classes.container, className, {\n        'entered': classes.entered,\n        'exited': !inProp && collapsedSize === '0px' && classes.hidden\n      }[state]),\n      style: _extends({\n        minHeight: collapsedSize\n      }, style),\n      ref: handleRef\n    }, childProps), /*#__PURE__*/React.createElement(\"div\", {\n      className: classes.wrapper,\n      ref: wrapperRef\n    }, /*#__PURE__*/React.createElement(\"div\", {\n      className: classes.wrapperInner\n    }, children)));\n  });\n});\nprocess.env.NODE_ENV !== \"production\" ? void 0 : void 0;\nCollapse.muiSupportAuto = true;\nexport default withStyles(styles, {\n  name: 'MuiCollapse'\n})(Collapse);","export default __webpack_public_path__ + \"static/julia1-10d24cd3303eec7e4895b7cf7862532e.jpg\";","import React from 'react';\nimport axios from 'axios';\nimport centroid from '@turf/centroid';\nimport mapboxgl from '!mapbox-gl';\nimport Card from '@material-ui/core/Card';\nimport CardContent from '@material-ui/core/CardContent';\nimport List from '@material-ui/core/List';\nimport ListItem from '@material-ui/core/ListItem';\nimport ListItemText from '@material-ui/core/ListItemText';\nimport Collapse from '@material-ui/core/Collapse';\nimport ExpandLess from '@material-ui/icons/ExpandLess';\nimport ExpandMore from '@material-ui/icons/ExpandMore';\nimport { useTranslation } from 'react-i18next';\nimport 'mapbox-gl/dist/mapbox-gl.css';\n\nimport neighborhoodSource from '../../data/neighborhoods';\nimport '../index.css';\nimport Form from './Form';\nimport logo from '../../images/julia1.jpg';\nimport LanguageMenu from './LanguageMenu';\n  \nmapboxgl.accessToken = process.env.GATSBY_MAPBOX_ACCESS_TOKEN;\nconst backend_url = process.env.BACKEND_URL;\nexport default class Map extends React.Component {\n\n    constructor(props) {\n        super(props);\n        this.state = {\n            organizationData: null,\n            dataLoaded: false,\n            lng: -71.073,\n            lat: 42.319,\n            zoom: 11\n        };\n        this.updateInformation = this.updateInformation.bind(this);\n    }\n\n    async componentDidMount() {\n        const res = await axios.get(backend_url + \"/listAllLocations\");\n        const organization_data = res.data;\n        // console.log(organization_data);\n        \n        // const bostonZipCodes = [\"02128\", \"02126\", \"02136\", \"02122\", \"02124\", \"02121\", \"02125\", \"02131\", \"02119\", \"02120\", \"02132\", \"02111\", \"02118\", \"02130\", \"02127\", \"02210\", \"02163\", \"02134\", \"02135\", \"02129\", \"02108\", \"02114\", \"02116\", \"02199\", \"02222\", \"02109\", \"02110\", \"02113\", \"02115\", \"02215\"]\n                \n        const { lng, lat, zoom } = this.state;\n        \n        // Create mapbox map\n        var map = new mapboxgl.Map({\n            container: 'map',\n            style: 'mapbox://styles/jkym2/ckni1o0zu06zh17qigui0dmuv',\n            center: [lng, lat],\n            zoom: zoom\n        });\n\n        // When map loads, add neighborhood layer data from source and add layer to map\n        map.on('load', function () {\n            map.addSource('neighborhoods', {\n                'type': 'geojson', data: neighborhoodSource\n            });\n\n            //\n            map.addLayer({\n                'id': 'neighborhoods-layer',\n                'type': 'fill',\n                'source': 'neighborhoods', // reference the data source\n                'layout': {},\n                'paint': {\n                    'fill-color': '#0080ff', // blue color fill\n                    'fill-opacity': 0.5\n                }\n            });\n                // Add a black outline around the polygon.\n            map.addLayer({\n                'id': 'outline',\n                'type': 'line',\n                'source': 'neighborhoods',\n                'layout': {},\n                'paint': {\n                    'line-color': '#000',\n                    'line-width': 3\n                }\n            });\n\n            var popup = new mapboxgl.Popup({\n                closeButton: false,\n                closeOnClick: false\n            });\n\n            map.on('click', 'neighborhoods-layer', function (event) { // callback function on mouse event\n\n                const coordinates = centroid(event.features[0]).geometry.coordinates;\n                const properties = event.features[0].properties;\n\n                document.getElementById(`neighborhood-${properties.Neighborhood_ID}`).scrollIntoView();\n                document.getElementById(`neighborhood-${properties.Neighborhood_ID}`).click();\n                \n                map.flyTo({\n                    center: coordinates,\n                    essential: true, // this animation is considered essential with respect to prefers-reduced-motion\n                    zoom: 12.5\n                });\n\n                while (Math.abs(event.lngLat.lng - coordinates[0]) > 180) {\n                    coordinates[0] += event.lngLat.lng > coordinates[0] ? 360 : -360;\n                }\n                \n                popup\n                    .setLngLat(coordinates)\n                    .setHTML(`<h3>${properties.Name}</h3>`)\n                    .addTo(map);\n            });\n\n\n            // Change the cursor to a pointer when the mouse is over the states layer.\n            map.on('mouseenter', 'neighborhoods-layer', function (event) {\n                map.getCanvas().style.cursor = 'pointer';\n\n                const coordinates = centroid(event.features[0]).geometry.coordinates;\n                const properties = event.features[0].properties;\n\n                while (Math.abs(event.lngLat.lng - coordinates[0]) > 180) {\n                    coordinates[0] += event.lngLat.lng > coordinates[0] ? 360 : -360;\n                }\n                \n                popup\n                    .setLngLat(coordinates)\n                    .setHTML(`<h3>${properties.Name}</h3>`)\n                    .addTo(map);\n            });\n                \n            // Change it back to a pointer when it leaves.\n            map.on('mouseleave', 'neighborhoods-layer', function () {\n                map.getCanvas().style.cursor = '';\n                popup.remove();\n            });\n        });\n        this.setState({\n            organizationData: organization_data,\n            dataLoaded: true,\n        })    \n    }\n\n    async updateInformation() {\n        const res = await axios.get(backend_url + \"/listAllLocations\");\n        const organization_data = res.data;\n        this.setState({\n            organizationData: organization_data,\n            dataLoaded: true,\n        })   \n    }\n\n    render() {\n        return (\n            <div className=\"main-container\">\n                <div className='sidebar'>\n                    <div className='languageMenu' style={{display: \"flex\", flexDirection: \"row\"}}>\n                        <LanguageMenu />\n                    </div>\n                    <div className='heading'>\n                        <div style={{display: \"flex\", flexDirection: \"row\", justifyContent: \"space-evenly\", alignItems: \"center\" }}>\n                            <img className=\"logo\" src={logo} style={{paddingRight: \"20px\"}}></img>\n                            <h2>Boston Mutual Aid</h2>\n                        </div>\n                        \n                        <Form parentCallback={this.updateInformation}/>\n                    </div>\n                    \n                    <div className=\"neighborhoods\">\n                        {this.state.dataLoaded ? \n                            <Neighborhoods neighborhoodData={neighborhoodSource} orgData={this.state.organizationData}></Neighborhoods> :\n                            false\n                        }\n                    </div>\n                </div>\n                <div className=\"map\" id=\"map\"></div>\n            </div>\n        );\n    }\n}\n\n\n\nfunction Neighborhoods (props) {\n    const neighborhoodData = props.neighborhoodData;\n    // console.log(neighborhoodData);\n    \n    const neighborhoodNames =  neighborhoodData.features.map((neighborhood) => {\n        return neighborhood.properties.Name;\n    });\n    \n    // console.log(d);\n    neighborhoodNames.sort();\n    // add Boston-wide to the front of the array\n    neighborhoodNames.unshift('Boston-wide');\n\n    const neighborhoods = [];\n    neighborhoodNames.forEach(name => {\n        // Boston-wide is a special case because it is not a neighborhood name\n        // the organizations in Boston-wide does not belong to a single neighborhood\n        if (name === \"Boston-wide\") {\n            const orgs = props.orgData.filter(i => {\n                return i.neighborhood.includes(name);\n            });\n            const bostonWide = {\n                Name: name,\n                orgs: orgs,\n            }\n            neighborhoods.push(bostonWide);\n        } else {\n            // grab neighborhood properties\n            const neighborhoodProps = neighborhoodData.features.find(n => {\n                return n.properties.Name === name;\n            }).properties;\n\n            const orgs = props.orgData.filter(i => {\n                return i.neighborhood.includes(name);\n            });\n\n            const nbh = {\n                Name: name, \n                Neighborhood_ID: neighborhoodProps.Neighborhood_ID,\n                orgs: orgs\n            }\n            neighborhoods.push(nbh);\n        }\n    });\n\n    return (\n        <List\n            component=\"div\"\n            className=\"neighborhoods\"\n            id=\"neighborhoods\"\n        >\n            {neighborhoods.map((neighborhood) => {\n                return (<Neighborhood key={`neighborhood-${neighborhood.Neighborhood_ID}`} neighborhood={neighborhood} orgs={neighborhood.orgs}/>);\n            })}\n        </List>\n    );\n}\n\nfunction Neighborhood(props) {\n\n    const { t } = useTranslation('translation');\n    // create component state(open) and state update method(setOpen)\n    const [open, setOpen] = React.useState(true);\n\n    // wrap the setOpen function with handleClick function\n    const handleClick = () => {\n      setOpen(!open);\n    };\n\n    return (\n      <div>\n        <ListItem button onClick={handleClick} id={`neighborhood-${props.neighborhood.Name === \"Boston-wide\" ? 0 : props.neighborhood.Neighborhood_ID }`}>\n          <ListItemText><h5>{t(props.neighborhood.Name)}</h5></ListItemText>\n          {open ? <ExpandMore /> : <ExpandLess />}\n        </ListItem>\n  \n        <Collapse in={!open} timeout=\"auto\" unmountOnExit>\n          {props.orgs.length !== 0 ? (props.orgs.map((org) => {\n            return(\n              <ListItem key={`org-${org.id}`}>\n                <Organization key={`org-${org.name}`} neighborhood={props.neighborhood.Name} org={org} />\n              </ListItem>);\n            })): \n\n            (<ListItem>\n              <ListItemText secondary=\"No organizations\"></ListItemText>\n            </ListItem>)}\n        </Collapse>\n      </div>\n    );\n  }\n  \n  function Organization(props) {\n      const org = props.org;\n      const { t } = useTranslation('translation');\n  \n      return(\n        <Card className=\"organization\">\n          <CardContent className=\"organization-info\">\n            <h5>{org.name}</h5>\n            <p>{t(props.neighborhood)}</p>\n            {org.email !== \"\" ? (<p>{org.email}</p>) : false}\n            {org.phone !== \"\" ? (<p>{org.phone}</p>)  : false}\n          </CardContent>\n  \n          <CardContent className=\"organization-links\">\n            {org.tags[0] === \"food\" ? <p>Food</p> : false}\n            {org.website !== \"\" ? (<a href={org.website}>{t('website')}</a>)  : false}\n            {org.give_help !== \"\" ? (<a href={org.give_help}>{t('give_help')}</a>)  : false}\n            {org.need_help !== \"\" ? (<a href={org.need_help}>{t('get_help')}</a>)  : false}\n          </CardContent>\n        </Card>\n      )\n  }"],"names":["_typeof","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","module","exports","obj","__esModule","cache","has","get","newObj","hasPropertyDescriptor","Object","defineProperty","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","deprecatedPropType","validator","reason","requirePropFactory","componentNameInError","unsupportedProp","props","propName","componentName","location","propFullName","useId","idOverride","_React$useState","defaultId","setDefaultId","id","concat","Math","round","random","_interopRequireDefault","_interopRequireWildcard","React","_default","default","createElement","d","value","enumerable","_utils","createSvgIcon","geom","properties","options","feat","type","bbox","geometry","coordinates","Error","Array","isArray","length","isNumber","num","isNaN","coordEach","geojson","callback","excludeWrapCoord","j","k","l","stopG","coords","geometryMaybeCollection","isGeometryCollection","wrapShrink","coordIndex","isFeatureCollection","isFeature","stop","features","featureIndex","geometries","geomIndex","multiFeatureIndex","geometryIndex","geomType","xSum","ySum","len","coord","Card","ref","classes","className","_props$raised","raised","other","Paper","root","elevation","withStyles","overflow","name","CardContent","_props$component","component","Component","padding","paddingBottom","defaultVariantMapping","h1","h2","h3","h4","h5","h6","subtitle1","subtitle2","body1","body2","Typography","_props$align","align","_props$color","color","_props$display","display","_props$gutterBottom","gutterBottom","_props$noWrap","noWrap","_props$paragraph","paragraph","_props$variant","variant","_props$variantMapping","variantMapping","capitalize","theme","margin","typography","caption","button","overline","srOnly","position","height","width","alignLeft","textAlign","alignCenter","alignRight","alignJustify","textOverflow","whiteSpace","marginBottom","colorInherit","colorPrimary","palette","primary","main","colorSecondary","secondary","colorTextPrimary","text","colorTextSecondary","colorError","error","displayInline","displayBlock","ListItemText","children","_props$disableTypogra","disableTypography","_props$inset","inset","primaryProp","primaryTypographyProps","secondaryProp","secondaryTypographyProps","dense","ListContext","multiline","flex","minWidth","marginTop","paddingLeft","Collapse","collapsedHeight","_props$collapsedSize","collapsedSize","collapsedSizeProp","_props$disableStrictM","disableStrictModeCompat","inProp","in","onEnter","onEntered","onEntering","onExit","onExited","onExiting","style","_props$timeout","timeout","_props$TransitionComp","TransitionComponent","Transition","useTheme","timer","wrapperRef","autoTransitionDuration","clearTimeout","current","enableStrictModeCompat","unstable_strictMode","nodeRef","handleRef","useForkRef","undefined","normalizedTransitionCallback","nodeOrAppearing","maybeAppearing","_ref","_ref2","node","isAppearing","handleEnter","handleEntering","wrapperHeight","clientHeight","transitionDuration","mode","duration","duration2","transitions","getAutoHeightDuration","handleEntered","handleExit","handleExited","handleExiting","addEndListener","nodeOrNext","maybeNext","next","setTimeout","state","childProps","container","entered","hidden","minHeight","wrapper","wrapperInner","muiSupportAuto","transition","create","visibility","mapboxgl","process","backend_url","Map","organizationData","dataLoaded","lng","lat","zoom","updateInformation","bind","componentDidMount","axios","res","organization_data","data","this","map","center","on","addSource","neighborhoodSource","addLayer","popup","closeButton","closeOnClick","event","centroid","document","getElementById","Neighborhood_ID","scrollIntoView","click","flyTo","essential","abs","lngLat","setLngLat","setHTML","Name","addTo","getCanvas","cursor","remove","setState","render","flexDirection","LanguageMenu","justifyContent","alignItems","src","logo","paddingRight","Form","parentCallback","Neighborhoods","neighborhoodData","orgData","neighborhoodNames","neighborhood","sort","unshift","neighborhoods","forEach","orgs","filter","i","includes","bostonWide","push","neighborhoodProps","find","n","nbh","List","Neighborhood","t","useTranslation","open","setOpen","ListItem","onClick","ExpandMore","ExpandLess","unmountOnExit","org","Organization","email","phone","tags","website","href","give_help","need_help"],"sourceRoot":""}